= 基本データ型



== 整数

前章で述べたように，整数は小数部や小数点がない数値です。

例えば``32``, `-174`, `0`, ``10_000_000``は全て整数です。3桁毎の区切りに``_``を用いて大きな数値を見やすくしていることに注目してください（1千万を10_000_000と書いた方が10000000と書くより分かりやすくなります)。

通常の数学演算子，加算（``+``），減算（``-``），乗算（``*``），そして除算（``/``）は期待した通りに動作します。最初の三つの演算子は整数を生成しますが，二つの整数の除算は，余りがない場合でも常に浮動小数点数（小数点のある数値）が結果として与えられます。

整数の除算（小数部が無視される除算）には``div``演算子を使います。演算子``mod``（modulus，法）は整数の除算の余りを得たいときに用います。これらの演算の結果は常に整数です。

[source]
.integers.nim
----
include::{source-dir}/integers.nim[]
----
<1> ``echo``コマンドはそれに続くコンマで区切られたもの全てを画面に印字します。この場合，まず文字``a + b = ``を印字し，続いて同じ行に式``a + b``の結果を印字します。

コードをコンパイルして実行すると出力は次のようになるはずです。
[source, output]
----
a + b = 15
a - b = 7
a * b = 44
a / b = 2.75
a div b = 2
a mod b = 3
----




== 浮動小数点数

浮動小数点数（float）実数のlink:https://en.wikipedia.org/wiki/Floating-point_arithmetic[近似表現]です。

例えば``2.73``, `-3.14`, `5.0`, ``4e7``は浮動小数点数です。大きな浮動小数点数には科学的表記を用いることに注目してください。``e``の後の数値は指数です。この例では，``4e7``は``4 * 10^7``を表します。

二つの浮動小数点数に対して，四つの基本数学演算子を用いることができます。演算子``div``と``mod``は浮動小数点数に対しては定義されていません。

[source]
.floats.nim
----
include::{source-dir}/floats.nim[]
----

[source, output]
----
c + d = 9.0  <1>
c - d = 4.5
c * d = 15.1875
c / d = 3.0  <1>
----
<1> 加算と除算の例では，小数部がない数値が得られますが，結果は浮動小数点型であることに注意してください。

数学演算の優先順位は期待通りです。乗算と除算は加算や減算よりも優先されます。

[source]
----
echo 2 + 3 * 4
echo 24 - 8 / 4
----

[source, output]
----
14
22.0
----




=== 浮動小数点数と整数の変換

Nimでは異なる数値型の変数間の数学演算が許されておらず，エラーが発生します。
[source]
----
let
  e = 5
  f = 23.456

echo e + f   # エラー
----

変数の値は同じ型に変換する必要があります。変換は簡単で整数への変換には``int``関数，浮動小数点数への変換には``float``関数を使います。
[source]
----
let
  e = 5
  f = 23.987

echo float(e)      <1>
echo int(f)        <2>

echo float(e) + f  <3>
echo e + int(f)    <4>
----
<1> ``float``に変換した整数``e``を印字する（``e``は整数のまま）。
<2> ``int``に変換した浮動小数点数``f``を印字する。
<3> 被演算子は共に浮動小数点数で加算可能。
<4> 被演算子は共に整数で加算可能。


[source, output]
----
5.0
23
28.987
28
----

NOTE: ``int``関数を使って浮動小数点数を整数に変換するときに四捨五入は行われません。単に数値から小数部が落ちるだけです。 +
四捨五入をするには別の関数を持ちなければなりませんが，それにはNimの使い方をもっと勉強する必要があります。




== 文字

``char``型は単一のlink:https://en.wikipedia.org/wiki/ASCII[ASCII]文字を表すために用いられます。

文字は二つの一重引用符（``'``）の間に書きます。文字はアルファベット，記号または数字です。複数の数字や文字はエラーになります。
[source]
----
let
  h = 'z'
  i = '+'
  j = '2'
  k = '35' # エラー
  l = 'xy' # エラー
----




== 文字列

文字列は文字が並んだものです。文字列の中身は二つの二重引用符 （``"``）の間に書きます。

文字列というと単語を思い浮かべますが，複数の単語や記号，数字を含むことができます。

[source]
.strings.nim
----
include::{source-dir}/strings.nim[]
----
<1> 空の文字列。
<2> これは数値（int）ではありません。二重引用符で囲まれているので，文字列になります。
<3> これは一つの文字ですが，二重引用符に囲まれているのでcharではありません。





=== 特殊文字

次の文字列を印字すると
[source]
----
echo "some\nim\tips"
----
意外な結果になります。
[source, output]
----
some
im	ips
----

このようになったのは，いくつかの文字には特別の意味があるからです。これらはエスケープ``\``を前につけて用います。

* ``\n``は改行です。
* ``\t``はタブです。
* ``\\``はバックスラッシュです（``\``はエスケープとして用いるため）。

上の例を文字通り印字するには，二つの方法があります。

* ``\\``を``\``の代わりに使うか，
* 未加工（raw）文字列を使います。文法は``r"..."``で （文字``r``を最初の引用符の前に置きます。）
）エスケープ文字が存在せず特別な意味もなく，全てがそのまま印字されます。

[source]
----
echo "some\\nim\\tips"
echo r"some\nim\tips"
----

[source, output]
----
some\nim\tips
some\nim\tips
----

上に示したもの以外にも特殊文字があり，link:https://nim-lang.org/docs/manual.html#lexical-analysis-string-literals[Nim manual]に示されています。





=== 文字列の結合

Nimの文字列は書き換え可能で，中身は変わり得ます。``add``関数で既存の文字列に別の文字列や文字を加える（付け足す）ことができます。元の文字列を変更したくないときは，文字列を``&``演算子で結合する（つなげる）と新しい文字列が返されます。

[source]
.stringConcat.nim
----
include::{source-dir}/stringConcat.nim[]
----
<1> 文字列を変更する場合は``var``として宣言します。
<2> 既存の文字列``p``に別の文字列を加えると，その文字列の値が変更されます。
<3> 文字列に``char``を加えることもできます。
<4> 二つの文字列を連結すると，元の文字列を変更せずに新しい文字列ができます。

[source, output]
----
p is now: abcdef
q is now: xyz
concat: abcdefxyz
p is still: abcdef
q is still: xyz
----






== 真偽

真偽（またはブール，``bool``）データ型は二つの値``true``か``false``のどちらかです。ブール型は通常制御の流れ（<<_流れの制御, 次章>>参照）に用いられ，通常関係演算子の結果です。

ブール変数に通常用いられる名前の付け方は，はい/いいえ（真/偽）の質問，例えば
``isEmpty``, ``isFinished``, ``isMoving``として表すというものです。



=== 関係演算子

関係演算子は，比較可能な二つの事柄の関係を試すものです。

二つの値はが等値かどうか比較するには``==``（二つの等号）が用いられます。これを以前に示した代入に用いられる``=``と混同しないようにしてください。

整数に対して定義されている全ての関係演算子を示します。

[source]
.relationalOperators.nim
----
include::{source-dir}/relationalOperators.nim[lines=1..11]
----

[source, output]
----
g is greater than h: false
g is smaller than h: true
g is equal to h: false
g is not equal to h: true
g is greater or equal to h: false
g is smaller or equal to h: true
----


文字や文字列を比較することもできます。

[source]
.relationalOperators.nim
----
include::{source-dir}/relationalOperators.nim[lines=13..30]
----
<1> 全ての大文字は小文字より前。
<2> 文字列の比較は文字毎に行われます。最初の三つの文字は同一で，文字``b``は文字``z``よりも小さい。
<3> 文字が同一でなければ，文字列の長さは比較されません。
<4> 短い文字列は長い文字列よりも小さい。

[source, output]
----
true
false
true
true
true
----




=== 論理演算子

論理演算子は一つまたはそれ以上の真偽値からなる式が真であるか試すために用いられます。

* 論理``and``が``true``を返すのは，両方とも``true``の場合のみ。
* 論理``or``が``true``を返すのは，少なくともどちらか一方が``true``のとき。
* 論理``xor``が``true``となるのは一方が真で他方がそうではないとき。
* 論理``not``は真偽を反転させます。つまり``true```を``false``にまたはその逆（一つの被演算子をとる唯一の論理演算子）

[source]
.logicalOperators.nim
----
include::{source-dir}/logicalOperators.nim[]
----

[source, output]
----
T and T: true
T and F: false
F and F: false
---
T or T: true
T or F: true
F or F: false
---
T xor T: false
T xor F: true
F xor F: false
---
not T: false
not F: true
----


関係演算子と論理演算子を組み合わせて，より複雑な式を作ることができます。

例えば，``(5 < 7) and (11 + 9 == 32 - 2*6)``は``true and (20 == 20)``となり，``true and true``なるので，最終結果は``true``となります。




== まとめ

この章はチュートリアルの中で最長でたくさんの範囲を扱いました。時間をとって各データ型を復習し，それぞれ何ができるか試してみてください。

型は一見制約のように見えますが，Nimコンパイラがコードを速く，偶発的におかしな動作をしないように確かめることを可能にするものです。これは大きなコードベースで役に立ちます。

基本型といくつかの演算を学んだので，Nimで簡単な計算ができます。知識を次の練習問題で試してみましょう。




== 練習問題

1. 書き換え不可の変数を作り，あなたの年齢（年）を格納してください。年齢を日数で印字してください（1年は365日とします）。
2. あなたの年齢が3で割り切れるか試してください。（ヒント: ``mod``を使います。）
3. 書き換え不可の変数を作り，あなたの身長をセンチメートルで格納してください。身長をインチで印字してください（1インチは2.54センチ）。
4. 管の直径が3/8インチです。直径をセンチメートルで表してください。
5. 書き換え不可の変数を二つ作り，あなたの姓と名を格納してください。変数``fullName``を二つの変数を連結して作ってください。姓と名の間には空白文字を入れてください。あなたのフルネームを印字してください。
6. アリスは$400を15日間毎に稼ぎます。ボブは1時間あたり$3.14稼ぎ，1日に8時間，週7日働いています。30日後，アリスはボブよりも稼いでいるでしょうか（ヒント: 関係演算子を使います）。
