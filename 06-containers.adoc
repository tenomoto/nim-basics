= コンテナ



コンテナは個々の要素の集まりを格納する型で，要素に対するアクセスができます。通常コンテナは反復可能で，<<_繰り返し, 繰り返しの章>>での文字列と同じように使うことができます。

例えば，日用品のリストは買いたい品目のコンテナで，素数のリストは数のコンテナです。擬似コードでは次のようになります。
[source]
----
groceryList = [ham, eggs, bread, apples]
primes = [1, 2, 3, 5, 7]
----



== 配列

配列は最も単純なコンテナ型です。配列は一様，すなわち配列内の全ての要素が同じ型です。配列の長さは一定，つまり要素の数（正確には要素の最大の数）はコンパイル時に既知でなくてはなりません。したがって，配列を「長さが一定の一様コンテナ」と呼ぶことができます。

配列の宣言は``array[<length>, <type>]``とします。ここで``length``は配列全体の大きさ（収容可能な要素の数）``type``は配列全ての要素の型です。宣言を省略できるのは，長さと型が共に渡された要素から推定できるときです。

配列の要素は角括弧で囲みます。

[source]
----
var
  a: array[3, int] = [5, 7, 9]
  b = [5, 7, 9]        <1>
  c = []  # error      <2>
  d: array[7, string]  <3>
----
<1> 値を与えると，``b``の長さと型はコンパイル時に既知です。配列``a``のように具体的に宣言することは正しいのですが，その必要はありません。
<2> この宣言では長さも型も推定できないので，エラーとなります。
<3> 空の（後で要素を満たす）配列を宣言する正しい方法は長さと型を与え，要素の値を与えません。配列``d``は七つの文字列を可能できます。


配列の長さはコンパイル時に既知でなければならないので，次は動作しません。

[source]
----
const m = 3
let n = 5

var a: array[m, char]
var b: array[n, char] # error <1>
----
<1> これがエラーとなるのは``n``が``let``を使って宣言されているので，その値はコンパイル時には分からない空です。配列の初期化に``length``として使えるのは``const``だけです。





== シーケンス

シーケンスは配列に似たコンテナですが，長さはコンパイル時に既知である必要はなく，実行中に変えることができます。含まれる要素の型だけを``seq[<type>]``で指定します。シーケンスは一様，すなわちシーケンスの全ての要素は同じ型でなくてはなりません。

シーケンスの要素は``@[``と``]``で囲みます。

[source]
----
var
  e1: seq[int] = @[]   <1>
  f = @["abc", "def"]  <2>
----
<1> 空のシーケンスの型は宣言しなくてはなりません。
<2> 空でないシーケンスの型は推定できます。この場合は，文字列を格納するシーケンスになります。

空のシーケンスを初期化する別の方法は，``newSeq``手続きを呼ぶことです。手続き呼び出しは<<_手続き, 次章>>で学びますが，ここではこのような方法もあることを覚えておきましょう。

[source]
----
var
  e = newSeq[int]() <1>
----
<1> 型パラメタを角括弧の間に与えて，特定の型のシーケンスが返されるようにします。 +
よくあるミスは最後の``()``を忘れることです。これは必ず付けなくてはなりません。


シーケンスに要素を付け加えるには``add``関数を使います。文字列に対して行ったことと似ています。追加を行うには，シーケンスは書き換え可能である（``var``で定義する）必要があり，追加される要素はシーケンスと同じ型でなくてはなりません。

[source]
.seq.nim
----
include::{source-dir}/seq.nim[]
----
<1> 同一の型（char）である新しい要素を追加。
<2> 同一の型を含む別のシーケンスを追加。

[source, output]
----
@['x', 'y', 'z']
@['1', '2', '3', 'x', 'y', 'z']
----

既存のシーケンスに異なる型を渡そうとすると，エラーが発生します。

[source]
----
var i = @[9, 8, 7]

i.add(9.81) # error <1>
g.add(i)    # error <2>
----
<1> ``int``のシーケンスに``float``を渡そうとしています。
<2> ``char``のシーケンスに``int``を渡そうとしています。


シーケンスの長さは変化するので長さを知る方法が必要です。長さは``len``関数を使うと得られます。

[source]
----
var i = @[9, 8, 7]
echo i.len

i.add(6)
echo i.len
----

[source, output]
----
3
4
----





== 要素指定と切り出し

要素指定により，インデックスによりコンテナから特定の要素を取り出すことができます。インデックスはコンテナ内の位置です。

Nimは他の多くのプログラミング言語と同様に0始まりのインデックスづけを採用しています。つまり，コンテナの最初の要素のインデックスは0で，二番目の要素のインデックスは1などとなります。

末尾からのインデックスには `^` を前に置きます。最後の要素（末尾から一つ目）のインデックスは `^1` です。

要素指定の構文は``<container>[<index>]``です。

[source]
.indexing.nim
----
include::{source-dir}/indexing.nim[lines=1..4]
----
<1> 0始まりの要素指定なでインデックス1の要素は``b``。
<2> 最後の要素を取得。

[source, output]
----
b
e
----

{nbsp}

切り出しでは一度に連続した要素が得られます。切り出しは（<<Forループ, forループの節>>で学んだ）範囲と同じ構文を使います。

``start .. stop``という構文を使うと両端は切り出しに含まれます。これに対し，``start ..< stop``ではインデックス``stop``は切り出しには含まれません。

切り出しの構文は``<container>[<start> .. <stop>]``です。

[source]
.indexing.nim
----
include::{source-dir}/indexing.nim[lines=6..8]
----

[source, output]
----
@[a, b, c, d]
@[a, b, c]
----


要素指定と切り出しは，既存の書き換え可能なコンテナと文字列に値を代入するときに使えます。

[source]
.assign.nim
----
include::{source-dir}/assign.nim[]
----
<1> 長さ5の配列のインデックスは0から4までです。配列のそれぞれの要素に値を代入しています。
<2> シーケンスの二番目の要素（インデックス1）に対して代入（書き換え）をしています。
<3> 文字列のインデックス8と9の文字を書き換えています。


[source, output]
----
[0, 7, 14, 21, 28]
@['p', 'q', 'r']
Tom and Barry
----




== タプル

これまでに学んだ二つのコンテナはどちらも一様でした。これに対し，タプルは非一様データを格納します。つまり，タプルの要素は異なっていても構いません。配列同様にタプルは固定長です。

タプルの要素は丸括弧で囲みます。

[source]
.tuples.nim
----
include::{source-dir}/tuples.nim[lines=1..3]
----
<1> タプルは異なる型のフィールドを含めることができます。この場合は``string``，``int``，そして``char``です。

[source, output]
----
(Field0: "Banana", Field1: 2, Field2: 'c')
----



タプルのフィールドには区別するための名前を付けることができます。名前を付けると，インデックスでなく名前でタプルの要素にアクセスできます。

[source]
.tuples.nim
----
include::{source-dir}/tuples.nim[lines=5..10]
----
<1> フィールドの値をフィールドのインデックスで変更。
<2> フィールドの値をフィールドの名前で変更。

[source, output]
----
(name: "Apple", weight: 7, rating: 'c')
----





== 練習問題

1. 10個の整数を格納できる空の配列を作ってください。
    * 数値10, 20, ..., 100で配列を入れてください。（ヒント: ループを使います。)
    * 奇数のインデックスである配列の要素だけを印字してください。（値は20, 40, ...）。
    * 偶数インデックスの要素を5枚してください。変更された配列を印字してください。

2. <<_練習問題_2, コラッツ予想の練習問題>>に再度取り組みます。ただし，今回は各段階で印字するのではなく，シーケンスに追加します。
    * 最初の数を選びます。面白い値には9, 19, 25や27などがあります。
    * 最初の数だけを要素とするシーケンスを作ります。
    * 前と同じロジックを使い，1にたどり着くまでシーケンスに要素を追加し続けます。
    * シーケンスの長さとシーケンス自体を印字します。

3. 2から100までの中で最も長いコラッツ数列を見つけてください。
    * 範囲内のそれぞれの数に対してコラッツ数列を計算します。
    * これまでの記録よりも現在のシーケンスが長ければ，現在の長さと最初の値を新しい記録として保存します。タプル``(longestLength, startingNumber)``または独立した二つの変数を使います。
    * 最長のシーケンスを与える最初の数とシーケンスの長さを印字します。
