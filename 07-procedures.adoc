= 手続き



手続き，又は他のプログラミング言語で__関数__とも呼ばれており，特定の作業をするコードの一部を一つの単位にまとめたものです。このようにコードをまとめる利点は，手続きに書いてある内容のコードを再度書き直す代わりに手続きを__呼び出す__ことができることです。

前の複数の章では，コラッツ予想にいくつかの方法で取り組みました。コラッツ予想のロジックを手続きにまとめていれば，同じコードをコラッツ予想の全ての練習問題で使うことができたはずです。

これまで多くの組込手続きを使ってきました。例えば，``echo``で印字し，``add``で要素をシーケンスに追加し，``inc``で整数の値を増加させ``len``でコンテナの長さを取得するなど。ここでは，自前の手続きを作成し，利用する方法を理解します。

手続きを使う利点はいくつかあります。

* コードの重複を防ぐ。
* 何をするかに基づいてコードの断片に名前を付けることでコードを読みやすくする。
* 複雑な作業を単純な段階に分解する。

この節の最初に述べたように，手続きは他の言語で関数とも呼ばれています。この定義は数学での関数の定義を考えると，呼び誤りとも言えます。数学の関数は引数の組を取り（``f(x, y)``のように。ここで``f``は関数で``x``と``y``はその引数），__常に__同一の入力に対して同一の答えを返します。

プログラムの手続きは，常に同じ値を返すとは限りません。時には，返り値がないこともあります。その理由は，コンピュータプログラムは状態を前に述べた変数に保存でき，手続きはこれを読み書きできるからです。Nimでは``func``は現在数学的により正確な，副作用がないという制約が課された関数を表すために使うために確保されています。



== 手続きの宣言

自前の手続きを使う（呼び出す）前に，作成し何をするか定義する必要があります。

手続きは``proc``キーワードを用いて宣言され，手続き名と確固で囲まれた入力パラメタとのそれらの型が続き，最後の部分はコロンと手続きから返される値の型であり，次のようになります。

[source]
----
proc <name>(<p1>: <type1>, <p2>: <type2>, ...): <returnType>
----

手続き本体は，``==``記号が後ろについた宣言の後に続いて，インデントしたブロックに書きます。

[source]
.callProcs.nim
----
include::{source-dir}/callProcs.nim[lines=1..8]
----
<1> この宣言の手続きの名前は``findMax``で，二つのパラメタ``x``と``y``をとり，``int``型を返します。
<2> 値を手続きから返すために``return``キーワードを使います。


{nbsp}

[source]
----
proc echoLanguageRating(language: string) = <1>
  case language
  of "Nim", "nim", "NIM":
    echo language, " is the best language!"
  else:
    echo language, " might be a second-best language."
----
<1> この``echoLanguageRating``手続きは与えられた名前を単におうむ返しするだけで，何も返さないので返り値の型は定義されていません。


{nbsp}

既定ではどのパラメタも変更することはゆるさていないので，次のように書くとエラーが発生します。

[source]
----
proc changeArgument(argument: int) =
  argument += 5

var ourVariable = 10
changeArgument(ourVariable)
----

動作するようにするには，Nimと手続きを使うユーザが引数を変更できるように，変数として宣言する必要があります。

[source]
----
proc changeArgument(argument: var int) = <1>
  argument += 5

var ourVariable = 10
changeArgument(ourVariable)
echo ourVariable
changeArgument(ourVariable)
echo ourVariable
----
<1> 注目すべきは，今度は``argument``が ``var int``として宣言されていて，単なる``int``ではないことです。

[source, output]
----
15
20
----

当然手続に渡す名前も変数として宣言されていなくてはならず，``const``や``let``が付与されているものはエラーが生じます。

引数で渡すことは良い慣行ですが，手続きの外で宣言された変数と定数を使うことも可能です。

[source]
----
var x = 100

proc echoX() =
  echo x  <1>
  x += 1  <2>

echoX()
echoX()
----
<1> ここで外部変数``x``にアクセスします。
<2> 変数として宣言されているので，値を更新することもできます。
[source, output]
----
100
101
----


== 手続きの呼び出し

手続きを宣言したら，呼び出しができます。多くのプログラミング言語で手続きや関数を呼びだす一般的な方法は名前を示し，次のように引数を括弧で囲むことです。

[source]
----
<procName>(<arg1>, <arg2>, ...)
----

手続き呼び出しの結果は変数に保存することができます。

``findMax``手続きを上の例から呼び返り値を変数に保存するには，次のようにします。

[source]
.callProcs.nim
----
include::{source-dir}/callProcs.nim[lines=10..18]
----
<1> 関数``findMax``の返り値はここで``c``と名付けられ，最初の二つの呼び出しの返り値を使って呼び出されます （``findMax(987, 321)``）。

[source, output]
----
987
321
987
----

{nbsp}

Nimは他の多くの言語とは異なり，link:https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax[統一関数呼び出し構文]が使えます。この構文を使うと，多様な呼び出し方が可能になります。

この構文では，最初の引数が関数名の前に書かれ，残りの引数を括弧の中に入れます。

[source]
----
<arg1>.<procName>(<arg2>, ...)
----

既にこの構文を使って，要素を既存のシーケンスに追加しました（``<seq>.add(<element>)``）。この方が``add(<seq>, <element>)``と書くよりも読みやすく，意図とが明確になります。引数の括弧を省略することも可能です。

[source]
----
<procName> <arg1>, <arg2>, ...
----

このようなスタイルが``echo``手続きを呼び出すときや，``len``手続きを引数なしに呼び出すときに使われていることを見てきました。これら二つを組み合わせることも可能ですが，見かけることはあまり多くありません。

[source]
----
<arg1>.<procName> <arg2>, <arg3>, ...
----


{nbsp}

統一呼び出し構文を使うと，複数の手続きをつなげるときに読みやすい書き方ができます。

[source]
.ufcs.nim
----
include::{source-dir}/ufcs.nim[]
----
<1> 複数のパラメタの型が同じであれば，型の宣言を簡潔に書くことができます。
<2> まず``a``に``b``を加え，演算の結果（2 + 3 = 5）``multi``手続きの最初の引数として与え，``c``を掛けます（5 * 4 = 20）。
<3> まず``c``と``b``を掛けて，演算の結果（4 * 3 = 12）を``plus``手続きの最初の引数として与え``a``を足します（12 + 2 = 14）。

[source, output]
----
true
true
20
14
----




== Result変数

Nimでは，値を返す全ての手続きは``result``変数が暗黙に宣言され，（既定値で）初期化されます。手続きは，インデントされたブロックの末尾に到達したら``return``文がなくても``result``変数を返します。

[source]
.result.nim
----
include::{source-dir}/result.nim[lines=1..9]
----
<1> 返り値の型は``int``で``result``変数は``int``の既定値``0``で初期化されます。
<2> 手続きの末尾に到達すると，``result``の値が返されます。

[source, output]
----
33
----

この手続きは``result``変数を説明するためのもので，100%正確ではありません。負の値だけを格納したシーケンスを渡すとこの手続きは（シーケンスに含まれ__ない__）``0``を返します。



{nbsp}


WARNING: 注意! Nimの古い版（Nim 0.19.0より前）文字列とシーケンスの既定値はlink:https//en.wikipedia.org/wiki/Null_pointer[`nil`]だったので，返り値の型として使うときには``result``変数はs（``""``）または空シーケンス（``@[]``）として初期化する必要がありました。

[source]
.result.nim
----
include::{source-dir}/result.nim[lines=11..20]
----
<1> Nimバージョン0.19.0以降ではこの行は不要。シーケンスは自動的に空シーケンスとして初期化されます。 +
Nimの古い版ではシーケンスを初期化しなければならず，この行がないとコンパイルエラー発生がしました（``result``は既に暗黙に宣言されているので，``var``は使ってはなりません。）

[source, output]
----
@[1, 43, 57]
----


{nbsp}

手続きの中で別の手続きを呼び出すことができます。

[source]
.filterOdds.nim
----
include::{source-dir}/filterOdds.nim[]
----
<1> ここも新しいNimの版では不要。
<2> 以前に宣言された手続きの呼び出し。返り値の型は``bool``でif文で使うことが可能。
<3> 上述の手続きを呼び出す第3の方法。

[source, output]
----
@[6, 9, 0, 3]
@[3]
@[45390, 3219]
----





== 前方宣言

この節の一番最初に述べたように，コードブロックを使わずに手続きを宣言することができます。その理由は手続きを呼び出す前に宣言する必要があるからです。次は動作しません。

[source]
----
echo 5.plus(10) # error      <1>

proc plus(x, y: int): int =  <2>
  return x + y
----
<1> ``plus``がまだ定義されていないので，エラーを生じます。
<2> ここで``plus``を定義していますが，使った後なのでNimはまだ知りません。

これを回避するには，前方宣言と呼ばれるものを使います。

[source]
----
proc plus(x, y: int): int    <1>

echo 5.plus(10)              <2>

proc plus(x, y: int): int =  <3>
  return x + y
----
<1> ここでNimに``plus``で続きが存在し，定義がこの通りであることを知らせます。
<2> 手続きを自由に使うことができ，これは動作します。
<3> ここで``plus``が実装されます。当然前にした定義と一致していなければなりません。





== 練習問題

1. 与えられた名前に対して挨拶する（"Hello <name>"を印字する）手続きを作ってください。名前のシーケンスを作り，この手続きを使ってそれぞれに人に挨拶してください。

2. 三つの値のうちで最大のものを返す手続き``findMax3``を作ってください。

3. 2次元平面の点は``tuple[x, y: float]``で表されます。二つの点を受け取り，二つの点の合計となる新しい点を返す手続きを書いてください（xとyは独立に足します）。

4. "tick"と"tock"という単語を印字する``tick``と``tock``という手続きを作ってください。何回走ったか記録する大域変数を用意し，交互にカウンタが20に達するまで走らせてください。期待される出力は"tick"と"tock"が20回交互に繰り返されるというものです。（ヒント: 前方宣言を使います）。

NOTE: 無限ループに入ってしまったときは，Ctrl+Cを押してプログラムの実行を止めることができます。

全ての手続きを異なるパラメタで実行してください。
